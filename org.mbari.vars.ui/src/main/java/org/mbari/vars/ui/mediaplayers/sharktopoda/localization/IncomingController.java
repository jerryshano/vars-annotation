package org.mbari.vars.ui.mediaplayers.sharktopoda.localization;

import com.google.gson.Gson;
import io.reactivex.subjects.PublishSubject;
import io.reactivex.subjects.Subject;
import javafx.collections.ListChangeListener;
import org.mbari.vars.core.EventBus;
import org.mbari.vars.services.model.Annotation;
import org.mbari.vars.services.model.Association;
import org.mbari.vars.services.model.Media;
import org.mbari.vars.ui.Data;
import org.mbari.vars.ui.commands.BulkCreateAnnotations;
import org.mbari.vars.ui.commands.Command;
import org.mbari.vcr4j.VideoIndex;
import org.mbari.vcr4j.sharktopoda.client.localization.IO;
import org.mbari.vcr4j.sharktopoda.client.localization.Localization;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Closeable;
import java.util.*;

/**
 * Controller that handles inbound traffic from remote app that's creating localizations.
 */
class IncomingController implements Closeable {
    private final EventBus eventBus;
    private final IO io;
    private final Gson gson;
    private final Data data;
    private final Logger logger = LoggerFactory.getLogger(getClass());
    private final Subject<Localization> internalBus;

    /**
     * IMPORTANT: We're only handling new additions of annotations, not deletes.
     * nor updates
     */
    private final ListChangeListener<Localization> changeListener = c -> {
        while (c.next()) {
            if (c.wasAdded()) {
                List<? extends Localization> addedSubList = c.getAddedSubList();
                if (!addedSubList.isEmpty()) {
                    addedSubList.forEach(x -> getInternalBus().onNext(x));
                }
            }
        }
    };

    /**
     * Constructor
     * @param eventBus This is the Apps main eventbus
     * @param io The IO Object used to connect via ZeroMQ to the remote app
     * @param gson For parsing the Localization
     * @param data The Data state object from UIToolbox
     */
    public IncomingController(EventBus eventBus, IO io, Gson gson, Data data) {
        this.eventBus = eventBus;
        this.io = io;
        this.gson = gson;
        this.data = data;
        PublishSubject<Localization> bus = PublishSubject.create();
        internalBus = bus.toSerialized();
        io.getController()
                .getLocalizations()
                .addListener(changeListener);
        internalBus.ofType(Localization.class)
                .distinct(Localization::getLocalizationUuid) // Cthulhu is sending dumplicate adds, need to filter these out
                .forEach(x -> addLocalizations(List.of(x)));
    }

    private Subject<Localization> getInternalBus() {
        return internalBus;
    }


    /**
     * Convert localizations to Annotations with a bounding box association
     * @param xs The list of localizations
     * @return Converted Annotations
     */
    public List<Annotation> localizationsToAnnotations(Collection<? extends Localization> xs) {
        Media media = data.getMedia();
        List<Annotation> annotations = new ArrayList<>();
        if (media != null) {
            // TODO Here we've been trying to preserve the loalizationUuid generated by Cthulhu.
            //   A better apporach
            //  1. Strip the UUIDs. Use the same create commands we've used else where.
            //  2. When the annotation is returned. Remove it from the localization collection
            //  3. Add the new localization
            logger.debug("Adding Localizations: " + xs);
            for (Localization x : xs) {
                logger.debug("Processing localization: {}", gson.toJson(x));
                // Does the annotation already exist?
                VideoIndex videoIndex = new VideoIndex(x.getElapsedTime());

                Optional<Annotation> opt = annotations.stream()
                        .filter(a -> a.getObservationUuid().equals(x.getAnnotationUuid()))
                        .findFirst();

                // TODO calculate recorded timestamp
                Annotation annotation = opt.orElseGet(() -> {
                    Annotation a = new Annotation(x.getConcept(),
                            data.getUser().getUsername(),
                            videoIndex,
                            media.getVideoReferenceUuid());
                    a.setDuration(x.getDuration());
                    if (x.getAnnotationUuid() != null) {
                        a.setObservationUuid(x.getAnnotationUuid());
                    } else {
                        a.setObservationUuid(UUID.randomUUID());
                    }
                    annotations.add(a);
                    return a;
                });

                BoundingBox bb = new BoundingBox(x.getX(), x.getY(), x.getWidth(), x.getHeight());
                String json = gson.toJson(bb);

                Association ass = new Association("bounding box",
                        Association.VALUE_SELF,
                        json,
                        "application/json",
                        x.getLocalizationUuid());

                logger.warn("Adding " + gson.toJson(ass));
                annotation.setAssociations(List.of(ass));

            }
        }
        return annotations;
    }

    private void addLocalizations(Collection<? extends Localization> xs) {

        // For now we're assuming that any externally created bounding box is a new annotation
        List<Annotation> annotations = localizationsToAnnotations(xs);

        // Do not add annotations that match existing observationUuids. This could cause
        // duplicates to be created.
        List<Annotation> existingAnnotations = new ArrayList<>(data.getAnnotations());
        annotations.removeAll(existingAnnotations);
        if (!annotations.isEmpty()) {
            Command cmd = new BulkCreateAnnotations(annotations);
            eventBus.send(cmd);
        }
    }

    /**
     * releases resources and cleans up
     */
    public void close() {
        io.getController()
                .getLocalizations()
                .removeListener(changeListener);
        internalBus.onComplete();
    }
}
